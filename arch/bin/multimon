#!/usr/bin/env python3
"""Control multiple monitors with xrandr."""

import os
from pathlib import Path
import subprocess
import sys
from collections.abc import Sequence
from time import sleep

import i3ipc


def multi(how, direction):
    """Set up multiple monitors using xrandr."""
    if how == 'init':
        _xrandr(how, direction)
        return

    i3 = i3ipc.Connection()
    rmap = _get_resize_map(i3)
    _xrandr(how, direction)
    sleep(0.5)
    _restart_dunst_and_polybar(how)
    sleep(0.5)
    _adjust_windows(i3, rmap)
    return


def _xrandr(how, direction):
    if how == 'init' or how == 'hotplug':
        # When starting or plugging and unplugging (using udev rules) wait a bit before
        # querying xrandr (because xrandr seems to lag)
        # FIXME: Must run `sudo udevadm control --reload` for hotplug?
        sleep(0.5)

    xrandr_out = [line.decode('ascii').split() for line in _sh('xrandr').splitlines()]
    monitors = [e[0] for e in xrandr_out if not e[0][0].isdigit()]
    conn = [lst for lst in xrandr_out if lst[1] == 'connected']
    nr_monitors = len(conn)

    # Primary monitor (assume it's the first connected monitor if it isn't
    # explicitly specified)
    prim = list(_flatten([i for i in conn if 'primary' in i]))
    if not prim:
        prim = conn[0]
    prim_n, prim_w, prim_h = _get_name_and_res(xrandr_out, prim)
    print(f"Primary monitor: {prim_n}-{prim_w}x{prim_h}")
    conn.remove(prim)

    # Multiple monitors
    # TODO: Use EDID for unique ordering?
    if nr_monitors > 1:
        sec = conn[0]
        sec_n, sec_w, sec_h = _get_name_and_res(xrandr_out, sec)
        print(f"Secondary monitor: {sec_n}-{sec_w}x{sec_h}")
        conn.remove(sec)
        if len(conn) > 0:
            third = conn[0]
            third_n, third_w, third_h = _get_name_and_res(xrandr_out, third)
            print(f"Third monitor: {third_n}-{third_w}x{third_h}")
            conn.remove(third)

    if how == 'init' or how == 'hotplug':
        how = 'primary' if nr_monitors == 1 else 'multi'

    if how == 'primary':
        cmd = f'--output {prim_n} --primary --dpi {PRIM_DPI * 2}'
        turn_off = [i for i in monitors if i not in ('Screen', 'VIRTUAL1', prim_n)]
        for m in turn_off:
            cmd += f' --output {m} --off'

    elif how == 'mirror':
        cmd = f'--output {sec_n} --auto --scale-from {prim_w}x{prim_h} --same-as {prim_n} '
        if nr_monitors == 3:
            cmd += f'--output {third_n} --auto --scale-from {prim_w}x{prim_h} --same-as {prim_n} '  # noqa
        cmd += f'--output {prim_n} --dpi {PRIM_DPI}'

    elif how == 'multi':
        # Assume the first monitor goes to the far left
        sec_scale = f'--scale {UP_SCALE}x{UP_SCALE}' if sec_w <= HD_WIDTH else ''
        cmd = f'--output {sec_n} {sec_scale} --auto --pos 0x0 '
        wpos = int(UP_SCALE * sec_w) if sec_w <= HD_WIDTH else sec_w
        hpos = 0 if direction == 'right' else int(UP_SCALE * sec_h)
        if nr_monitors == 3:
            # The second monitor is right to the first monitor
            third_scale = (
                f'--scale {UP_SCALE}x{UP_SCALE}' if third_w <= HD_WIDTH else ''
            )
            cmd += f'--output {third_n} {third_scale} --auto --pos {wpos}x0 '
            # Primary is in the middle below the 2 monitors
            wpos = wpos - int(prim_w / 2)
            hpos = int(UP_SCALE * sec_h)
        elif nr_monitors == 2:
            # With only 1 extra monitor place the primary monitor below or to the right
            # depending on direction value
            wpos = wpos if direction == 'right' else 0
        cmd += (
            f'--output {prim_n} --scale {DOWN_SCALE}x{DOWN_SCALE} --primary '
            f'--pos {wpos}x{hpos} --dpi {PRIM_DPI}'
        )

    cmd = f'xrandr {cmd}'
    print(f"Running the following xrandr command: {cmd}")
    _sh(cmd)

    # Ensure correct XResources
    xrdb_cmd = f'xrdb -merge {str(Path.home())}/.Xresources'
    if how == 'primary':
        xrdb_cmd += '_hidpi'
    print(f"Running the following xrdb command: {xrdb_cmd}")
    _sh(xrdb_cmd)


def _get_resize_map(i3):
    res_map = {}
    tree = i3.get_tree()
    workspaces = tree.workspaces()
    for ws in workspaces:
        for w in ws.leaves():
            res_map[w.id] = {
                'win': w,
                'focused': w.focused,
                'how': _find_how_to_resize(i3, w),
            }
    return res_map


def _adjust_windows(i3, resize_map):
    for win_id, win_data in resize_map.items():
        i3.command(f'[con_id={win_id}] focus')
        while not i3.get_tree().find_focused().id == win_id:
            sleep(0.1)
        x, y, w, h = win_data['how']
        _resize_win(i3, x, y, w, h)

        if win_data['focused']:
            focused_win_id = win_id
    i3.command(f'[con_id={focused_win_id}] focus')
    return


def _restart_dunst_and_polybar(how):
    how = 'xrandr' if how != 'mirror' else how
    polybar_launch_file = os.path.expanduser('~/.config/polybar/launch.py')
    os.system(f'python {polybar_launch_file} -m {how}')
    sleep(0.2)
    _sh('pkill -f dunst')
    _sh_no_block('nohup dunst &', stdout=subprocess.DEVNULL)
    return


# Helpers
def _find_how_to_resize(i3, win=None):
    if win is None:
        win = i3.get_tree().find_focused()
    win_h = win.rect.height
    win_w = win.rect.width
    win_x = win.rect.x
    win_y = win.rect.y

    ws = win.workspace()
    max_h = ws.rect.height
    max_w = ws.rect.width
    max_x = ws.rect.x
    max_y = ws.rect.y

    w = round(win_w / max_w, 2)
    h = round(win_h / max_h, 2)
    x = round((win_x + 1 - max_x) / max_w, 2)
    if x > 1:
        # If win_x is wrongly reported then the factor will > 1; in these
        # cases the actual x value should be 0
        x = 0
    y = round((win_y - max_y) / max_h, 2)

    return x, y, w, h


def _resize_win(i3, x, y, w, h):
    win = i3.get_tree().find_focused()
    ws = win.workspace()
    max_h = ws.rect.height
    max_w = ws.rect.width
    max_x = ws.rect.x
    max_y = ws.rect.y

    x = int(max_x + (max_w * x))
    # Fix for incorrect calculation when monitor extends right
    # TODO: Find a better way of doing this
    x -= 1
    y = int(max_y + (max_h * y))

    polybar_height = 55 if ws.ipc_data['output'] == 'eDP1' else 28
    if y < polybar_height:
        # We always want to leave space for polybar
        y = polybar_height
    w = int(max_w * w)
    h = int(max_h * h)
    cmd = (
        f"fullscreen disable, floating enable, "
        f"move position {x} {y}, resize set {w} {h}"
    )
    i3.command(cmd)
    return


def _get_name_and_res(xrandr_out, mon_info):
    # Name is the first element and active resolution is the line immediately
    # after the monitor info marked with `+` (or `*+`)
    mon_name = mon_info[0]
    start_index = xrandr_out.index(mon_info) + 1
    resolutions = xrandr_out[start_index:]

    for r in resolutions:
        res = r[0]
        # If the resolution doesn't start with a digit then we exausted all possible resolutions
        if not res[0].isdigit():
            used_res = resolutions[0][0]
            break
        if any('*' in e or '+' in e for e in r):
            used_res = res
            break

    mon_w, mon_h = tuple([int(i) for i in used_res.split('x')])
    return mon_name, mon_w, mon_h


def _sh(cmd, *args, **kwargs):
    res, _ = _sh_no_block(cmd, *args, stdout=subprocess.PIPE, **kwargs).communicate()
    return res


def _sh_no_block(cmd, *args, **kwargs):
    if isinstance(cmd, str):
        cmd = cmd.split()
    return subprocess.Popen(cmd, *args, **kwargs)


def _flatten(lst):
    for i in lst:
        if isinstance(i, Sequence) and not isinstance(i, (str, bytes)):
            yield from _flatten(i)
        else:
            yield i


if __name__ == '__main__':
    import argparse

    parser = argparse.ArgumentParser()
    parser.add_argument('how')
    parser.add_argument('direction', nargs='?', default='right')
    parse_args = parser.parse_args()

    # Constants
    PRIM_DPI = 96
    UP_SCALE = 1
    DOWN_SCALE = 1
    HD_WIDTH = 1920
    VALID_MODES = ['init', 'hotplug', 'primary', 'mirror', 'multi']
    VALID_DIRECTIONS = ['right', 'below']

    chosen_mode = parse_args.how
    if chosen_mode not in VALID_MODES:
        raise ValueError(
            f"{chosen_mode} invalid! Valid modes are: {', '.join(VALID_MODES)}"
        )
    chosen_direction = parse_args.direction
    if chosen_direction not in VALID_DIRECTIONS:
        raise ValueError(
            f"{chosen_direction} invalid! Valid directions are: {', '.join(VALID_DIRECTIONS)}"
        )

    multi(chosen_mode, chosen_direction)
    sys.exit(0)
